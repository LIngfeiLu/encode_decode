/* First partner's name: Lingfei Lu, A91046735
 * Second partner's name: Junxi Li, A91105747
 */
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include "common.h"
#include "encoder.h"
/**
 *
 * This function takes a char c as input and returns a (6 character) array
 * that represents the 6 digit code for that character. This code is simply
 * the index of the char in the MAPPING array (represented in binary). 
 * You should use the REVERSE\_MAPPING array in this function to get 
 * the binary code for the character. REVERSE\_MAPPING array MUST be 
 * initialized with createReverseMapping(), prior to calling this function.
 *
 * @param c The input character to encode
 * @returns a six character array which encodes the index into ASCII binary
 */
char* encodeChar(char c){
    //malloc 6 bytes for char array output
    char *output = (char*)malloc(6);
    //if malloc fails, then return NULL
    if(output == NULL)
        return NULL;
    int i, index, temp;
    //get the index of input character c
    index = REVERSE_MAPPING[c];

    //loop to create an character array
    for(i = 0; i < 6; i++){
        //get every binary number corresponding to input character c
        temp = (unsigned int)index >> i;
        temp = temp & 0x1;
        //get character '0' or '1'
        *(output + 5 - i) = temp + 48;
    }
    //return character array with '0' and '1'
    return output;
}

/**
 * Takes a char c and int bit (should be either 0 or 1) and int index as input. 
 * Sets the bit at input index of c to be the input bit and returns the result.
 * The 0 index refers to the LSB, so for example, index 2 should 
 * set the 3rd least significant bit.
 * 
 * @param c the char to implant a bit into
 * @param bit the bit value to implant (0 or 1)
 * @param index the index to implant the bit into (0 is LSB)
 * @returns the char with bit b implanted into the input index
 */
char implantBit(char c, int bit, int index){
    //the bit we want to implant and shift right to that position
    char temp = bit << index;
    //use bit clear mask
    char one = 1 << index;
    //bit clear that index position 
    char store = c & ~one;
    //replace that position with whatever is in temp,
    //whcih is the bit we want to implant
    char output = store | temp;
    return output;
}

/**
 * Takes a FILE handle in as input (corresponding to a regular ASCII
 * text file) and reads the file, char by char. Encodes each char into
 * a 6 character "binary" char array (by calling encodeChar).  The
 * resulting character arrays should be written to the output file
 * handle out
 *
 * @param in The input text file to read
 * @param out The output file, in ASCII encoded "binary"
 */
void textToBinary(FILE *in, FILE *out){
    int i;

    //check if inputs are null or not
    if(in == NULL || out == NULL)
        return;


    while(1)
    {
        //get 1 byte from input file
        char character = fgetc(in);
        //check is reach the end of file
        if(feof(in))
        {
            break;
        }

        //first encode character to a 6 digits character arry
        char *arr = encodeChar(character);
        //check is encodeChar fails
        if(arr == NULL)
            return;
        //write to file
        for(i = 0; i < 6; i++)
        {
            fputc(arr[i], out);
        }
    }
}

/**
 * Takes a FILE handle in as input (corresponding to a
 * "binary" encoded file) and reads the file 1 char at a time. Each
 * char read will be an ASCII '0' or ASCII '1', and either 0 or 1 
 * will be implanted into randomized chars generated by rand()%256.
 *
 * If ASCII '0', then implant 0 into the bit at the input index 
 * of a randomized char . If ASCII '1', then implant 1 into the bit at 
 * the input index of the randomized char (by calling implantBit). 
 * Write the result into the output file handle out 
 * (Note: The least significant bit is in index 0)
 *
 * @param in The input file handle to read (ASCII encoded binary)
 * @param out The output file to write to
 * @param index the index of the bit where binary values should be implanted (0 is LSB)
 */
void binaryToCode(FILE *in, FILE *out, int index){
    if(in == NULL || out == NULL)
        return;
    srand(1); //DO NOT REMOVE OR EDIT THIS LINE OF CODE
    while(1)
    {
        //generate random character
        //char random = (unsigned char)rand()%256;
        //get 1 character from input file
        char temp = fgetc(in);
        char random = rand()%256;

        //check if reach the end of file
        if(feof(in))
        {
            break;
        }
        char character;
        //if temp is 0, then implant 0
        if(temp == '0')
        {
            character = implantBit(random, 0, index);
        }
        //else implant 1
        else{
            character = implantBit(random, 1, index);
        }
        //write to characters to file
        fprintf(out, "%c", character);

    }
}

/**
 * Reads in a file from the specified input path and outputs a a binary encoding to
 * specified bin path and a fully encoded version to specified output path. 
 * This should simply open the necessary files and call the above helper 
 * functions in the correct sequence, and close the necessary files.
 *
 * @param input the path to the input file
 * @param bin the path to the encoded ASCII binary output file
 * @param output the path to the encoded output file 
 * @param index The index of the bit where binary values should be implanted (0 is LSB)
 */
void encodeFile(char* input, char* bin, char* output, int index){
    //check if input files are different
    if(input == NULL || bin == NULL || output == NULL)
        return;
    //open in and binary
    FILE *in = fopen(input, "r");
    FILE *binary = fopen(bin, "w");
    //check is open correctly
    if(in == NULL || output == NULL)
        return;

    //transform input file to binary representation
    textToBinary(in, binary);

    //close file binary
    fclose(binary);
    //open bin in read mode
    binary = fopen(bin, "r");
    //open charater in write mode
    FILE *character = fopen(output, "w");
    //check if fopen correctly
    if(binary == NULL || character == NULL)
        return;
    //transoform binary to encoded character file
    binaryToCode(binary, character, index);

    //close files
    fclose(in);
    fclose(binary);
    fclose(character);
}


